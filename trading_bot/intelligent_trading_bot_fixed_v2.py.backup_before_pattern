#!/usr/bin/env python3
"""
FIXED V2 - Intelligent Trading Bot with Data Format Fix
Includes position sync, correct exit logic, safety checks, and data column fixes
"""

import asyncio
import sys
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import pandas as pd
import numpy as np
import json
import logging
from enum import Enum
from dataclasses import dataclass

# Add paths
sys.path.append('/Users/royaltyvixion/Documents/XTRADING/trading_bot')
sys.path.append('/Users/royaltyvixion/Documents/XTRADING/web_platform/backend')

# Import bot components
from data.data_loader import HybridDataLoader, DataConfig, DataMode
from data.feature_engineering import FeatureEngineer
from analysis.optimized_pattern_scanner import OptimizedPatternScanner as PatternScanner, PatternType
from analysis.microstructure import MicrostructureAnalyzer
from execution.confidence_engine import AdvancedConfidenceEngine, TradeAction

# Import TopStep components
from brokers.topstepx_client import topstepx_client


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/Users/royaltyvixion/Documents/XTRADING/trading_bot/bot_fixed_v2.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


# DISABLED PATTERNS with poor performance
DISABLED_PATTERNS = ['volume_climax', 'multi_pattern', 'mean_reversion']


class BotState(Enum):
    """Bot operational states"""
    INITIALIZING = "initializing"
    READY = "ready"
    TRADING = "trading"
    POSITION_OPEN = "position_open"
    CLOSING_POSITION = "closing_position"
    PAUSED = "paused"
    ERROR = "error"
    STOPPED = "stopped"


@dataclass
class Position:
    """Active position tracking with proper type"""
    symbol: str
    side: int  # 0=BUY/LONG, 1=SELL/SHORT (TopStep format)
    position_type: int  # 1=LONG, 2=SHORT (internal tracking)
    size: int
    entry_price: float
    entry_time: datetime
    stop_loss: float
    take_profit: float
    pattern: Optional[PatternType]
    confidence: float
    order_id: Optional[str] = None
    pnl: float = 0
    status: str = "open"


@dataclass
class RiskLimits:
    """Risk management limits"""
    max_daily_loss: float = 1500  # TopStep 50K account limit
    max_position_size: int = 3  # Maximum 3 contracts
    max_positions: int = 1
    trailing_stop_percent: float = 0.01  # 1% trailing stop
    risk_per_trade: float = 500  # Max risk per trade


class IntelligentTradingBotFixedV2:
    """FIXED V2 trading bot with proper data handling"""
    
    def __init__(self, 
                 account_id: int = 10983875,
                 symbol: str = "NQ.FUT",
                 mode: str = "paper",
                 min_confidence: float = 50):  # RAISED back to 50% minimum
        """Initialize fixed intelligent trading bot V2"""
        self.account_id = account_id
        self.symbol = symbol
        self.mode = mode
        self.state = BotState.INITIALIZING
        
        # Contract ID for NQ
        self.contract_id = "CON.F.US.ENQ.U25"
        
        # Initialize components
        self.data_loader = HybridDataLoader(DataConfig(mode=DataMode.HYBRID))
        self.feature_engineer = FeatureEngineer()
        self.pattern_scanner = PatternScanner(min_strength=40)
        self.microstructure_analyzer = MicrostructureAnalyzer()
        self.confidence_engine = AdvancedConfidenceEngine(min_confidence=min_confidence)
        
        # FIXED: Proper position tracking
        self.current_position: Optional[Position] = None
        self.current_position_type: Optional[int] = None  # 1=LONG, 2=SHORT
        self.current_position_size: int = 0
        self.broker_position_cache = None
        self.last_position_sync = None
        
        # Risk management
        self.risk_limits = RiskLimits()
        self.daily_pnl = 0
        self.trade_count = 0
        self.winning_trades = 0
        self.losing_trades = 0
        
        # Position state lock
        self.position_state_lock = asyncio.Lock()
        self.is_exiting = False
        self.last_exit_time = None
        self.exit_cooldown = 60
        
        # Performance tracking
        self.performance_history = []
        self.pattern_performance = {}
        self.current_pattern_confidence = 0
        
        # Control flags
        self.running = False
        self.last_update_time = None
        
        logger.info(f"FIXED V2 Bot initialized for {symbol} on account {account_id}")
    
    def standardize_dataframe(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Standardize dataframe columns to ensure compatibility
        Maps various column names to standard OHLCV format
        """
        if df.empty:
            return df
        
        # Common column mappings
        column_mappings = {
            # Price columns
            'Open': 'open', 'o': 'open', 'O': 'open',
            'High': 'high', 'h': 'high', 'H': 'high',
            'Low': 'low', 'l': 'low', 'L': 'low',
            'Close': 'close', 'c': 'close', 'C': 'close',
            'Volume': 'volume', 'v': 'volume', 'V': 'volume',
            # Alternative names
            'open_price': 'open', 'high_price': 'high',
            'low_price': 'low', 'close_price': 'close',
            'vol': 'volume', 'qty': 'volume'
        }
        
        # Rename columns
        df_copy = df.copy()
        for old_col, new_col in column_mappings.items():
            if old_col in df_copy.columns:
                df_copy = df_copy.rename(columns={old_col: new_col})
        
        # Ensure required columns exist
        required_cols = ['open', 'high', 'low', 'close', 'volume']
        for col in required_cols:
            if col not in df_copy.columns:
                if col == 'volume':
                    df_copy[col] = 1000  # Default volume
                else:
                    # Try to find any price column as fallback
                    price_cols = [c for c in df_copy.columns if 'price' in c.lower() or c in ['open', 'high', 'low', 'close']]
                    if price_cols:
                        df_copy[col] = df_copy[price_cols[0]]
                    else:
                        logger.warning(f"Missing required column: {col}")
                        return pd.DataFrame()  # Return empty if can't create required columns
        
        return df_copy
    
    async def initialize(self):
        """Initialize bot systems and connections"""
        logger.info("Initializing FIXED V2 bot systems...")
        
        try:
            # Connect to TopStep
            logger.info("Connecting to TopStep API...")
            await topstepx_client.connect()
            
            if not topstepx_client.connected:
                raise Exception("Failed to connect to TopStep API")
            
            logger.info("TopStep API connected successfully")
            
            # CRITICAL: Force sync positions on startup
            await self.sync_positions_with_broker()
            
            # Load initial data
            logger.info("Loading initial market data...")
            end_time = datetime.utcnow()
            start_time = end_time - timedelta(hours=24)
            
            initial_data = await self.data_loader.load_data(
                start_time, end_time, self.symbol, "1m"
            )
            
            # Standardize data format
            initial_data = self.standardize_dataframe(initial_data)
            
            if initial_data.empty:
                logger.warning("No initial data loaded")
            else:
                logger.info(f"Loaded {len(initial_data)} bars of initial data")
                logger.info(f"Data columns: {initial_data.columns.tolist()}")
            
            self.state = BotState.READY
            logger.info("Bot initialization complete with position sync")
            
        except Exception as e:
            logger.error(f"Initialization failed: {e}")
            self.state = BotState.ERROR
            raise
    
    async def sync_positions_with_broker(self):
        """FIXED: Force sync positions with TopStep"""
        logger.info("=== SYNCING POSITIONS WITH BROKER ===")
        
        try:
            response = await topstepx_client.request('POST', '/api/Position/searchOpen', {
                "accountId": self.account_id
            })
            
            if response and response.get('success'):
                positions = response.get('positions', [])
                
                # Clear internal state first
                self.current_position_type = None
                self.current_position_size = 0
                self.current_position = None
                
                # Rebuild from broker state
                nq_position = None
                for pos in positions:
                    if 'NQ' in pos.get('contractId', '') or 'ENQ' in pos.get('contractId', ''):
                        nq_position = pos
                        break
                
                if nq_position:
                    size = nq_position.get('size', 0)
                    side = nq_position.get('side', 0)
                    avg_price = nq_position.get('avgPrice', 0)
                    
                    self.current_position_size = abs(size)
                    self.current_position_type = 1 if side == 0 else 2
                    
                    self.current_position = Position(
                        symbol=self.symbol,
                        side=side,
                        position_type=self.current_position_type,
                        size=self.current_position_size,
                        entry_price=avg_price,
                        entry_time=datetime.utcnow(),
                        stop_loss=avg_price - 10 if self.current_position_type == 1 else avg_price + 10,
                        take_profit=avg_price + 10 if self.current_position_type == 1 else avg_price - 10,
                        pattern=None,
                        confidence=0
                    )
                    
                    position_type_str = "LONG" if self.current_position_type == 1 else "SHORT"
                    logger.warning(f"SYNCED: {self.current_position_size} {position_type_str} contracts @ {avg_price}")
                else:
                    logger.info("NO POSITIONS found in broker - starting flat")
                
                self.broker_position_cache = positions
                self.last_position_sync = datetime.utcnow()
                
            else:
                logger.error(f"Failed to sync positions: {response}")
                
        except Exception as e:
            logger.error(f"Position sync error: {e}")
    
    async def close_position(self, reason=""):
        """FIXED: Proper exit logic"""
        async with self.position_state_lock:
            if self.current_position_size == 0:
                logger.error("ERROR: No position to close")
                return False
            
            if self.is_exiting:
                logger.warning("Already exiting position, skipping")
                return False
            
            self.is_exiting = True
            
            try:
                if self.current_position_type == 1:  # LONG
                    exit_side = 1  # SELL to close
                    side_str = "SELL"
                elif self.current_position_type == 2:  # SHORT
                    exit_side = 0  # BUY to close
                    side_str = "BUY"
                else:
                    logger.error(f"ERROR: Unknown position type: {self.current_position_type}")
                    return False
                
                order_params = {
                    "accountId": self.account_id,
                    "contractId": self.contract_id,
                    "type": 2,
                    "side": exit_side,
                    "size": self.current_position_size
                }
                
                position_type_str = "LONG" if self.current_position_type == 1 else "SHORT"
                logger.info(f"CLOSING {self.current_position_size} {position_type_str} contracts")
                logger.info(f"Exit order: {side_str} {self.current_position_size} @ MARKET")
                logger.info(f"Reason: {reason}")
                
                response = await topstepx_client.submit_order(
                    self.account_id,
                    self.contract_id,
                    2,
                    exit_side,
                    self.current_position_size
                )
                
                if response and response.get('success'):
                    logger.info(f"âœ… Exit order placed: {response.get('orderId')}")
                    
                    self.current_position = None
                    self.current_position_type = None
                    self.current_position_size = 0
                    self.last_exit_time = datetime.utcnow()
                    
                    return True
                else:
                    logger.error(f"Failed to place exit order: {response}")
                    return False
                    
            except Exception as e:
                logger.error(f"Exit position error: {e}")
                return False
            finally:
                self.is_exiting = False
                self.state = BotState.READY
    
    async def pre_trade_checks(self):
        """Safety checks before trades"""
        logger.info("=== PRE-TRADE SAFETY CHECKS ===")
        
        await self.sync_positions_with_broker()
        
        if self.current_position_size >= self.risk_limits.max_position_size:
            logger.warning(f"BLOCKED: At max position size ({self.current_position_size})")
            return False
        
        if self.last_exit_time:
            seconds_since_exit = (datetime.utcnow() - self.last_exit_time).total_seconds()
            if seconds_since_exit < self.exit_cooldown:
                logger.info(f"In cooldown: {self.exit_cooldown - seconds_since_exit:.0f}s")
                return False
        
        if self.current_pattern_confidence < 50:
            logger.warning(f"BLOCKED: Low confidence ({self.current_pattern_confidence:.1f}%)")
            return False
        
        if self.daily_pnl <= -self.risk_limits.max_daily_loss:
            logger.error(f"BLOCKED: Daily loss limit (${self.daily_pnl:.2f})")
            return False
        
        logger.info("âœ… All pre-trade checks passed")
        return True
    
    async def run(self):
        """Main trading loop"""
        logger.info("Starting FIXED V2 intelligent trading bot...")
        self.running = True
        
        try:
            while self.running:
                # Check rate limit health if available
                if hasattr(topstepx_client, 'general_limiter') and topstepx_client.general_limiter:
                    usage = topstepx_client.general_limiter.get_current_usage()
                    
                    # Emergency stop at 95%
                    if usage['percentage'] >= 95:
                        logger.critical(f"ðŸš¨ NQ Bot EMERGENCY STOP - Rate limit critical at {usage['percentage']:.0f}%!")
                        self.running = False
                        break
                    
                    # Pause at 90%
                    if usage['percentage'] >= 90:
                        logger.warning(f"ðŸ›‘ NQ Bot pausing - Rate limit at {usage['percentage']:.0f}%")
                        await asyncio.sleep(30)  # Emergency pause
                        continue
                
                if self.state == BotState.ERROR:
                    logger.error("Bot in error state, stopping...")
                    break
                
                if self.state == BotState.PAUSED:
                    await asyncio.sleep(5)
                    continue
                
                # Periodic position sync
                if self.last_position_sync:
                    minutes_since_sync = (datetime.utcnow() - self.last_position_sync).total_seconds() / 60
                    if minutes_since_sync > 5:
                        await self.sync_positions_with_broker()
                
                if not self._check_risk_limits():
                    logger.warning("Risk limits exceeded, pausing")
                    self.state = BotState.PAUSED
                    await asyncio.sleep(60)
                    continue
                
                await self._trading_cycle()
                
                # Adaptive loop timing based on market conditions and rate limits
                base_sleep = 5  # Default sleep time
                
                # Adjust for confidence
                if hasattr(self, 'current_confidence') and self.current_confidence:
                    if self.current_confidence > 40:
                        base_sleep = 3  # Faster when hunting
                    elif self.current_confidence > 20:
                        base_sleep = 5  # Normal speed
                    else:
                        base_sleep = 10  # Slower when quiet
                
                # Adjust for rate limit usage
                if hasattr(topstepx_client, 'smart_throttle') and topstepx_client.smart_throttle:
                    adjusted_sleep = topstepx_client.smart_throttle.get_sleep_time(base_sleep)
                    await asyncio.sleep(adjusted_sleep)
                else:
                    await asyncio.sleep(base_sleep)
                
        except KeyboardInterrupt:
            logger.info("Bot stopped by user")
        except Exception as e:
            logger.error(f"Bot error: {e}", exc_info=True)
            self.state = BotState.ERROR
        finally:
            await self.shutdown()
    
    async def _trading_cycle(self):
        """Execute one trading cycle with data standardization"""
        try:
            end_time = datetime.utcnow()
            start_time = end_time - timedelta(hours=4)
            
            data = await self.data_loader.load_data(
                start_time, end_time, self.symbol, "1m"
            )
            
            # CRITICAL: Standardize data format
            data = self.standardize_dataframe(data)
            
            if data.empty or len(data) < 30:
                logger.debug("Insufficient data for analysis")
                return
            
            # Verify data has required columns
            if 'close' not in data.columns:
                logger.error(f"Data missing 'close' column. Available columns: {data.columns.tolist()}")
                return
            
            if self.current_position:
                await self._manage_position(data)
            else:
                await self._look_for_entry(data)
            
            self.last_update_time = datetime.utcnow()
            
        except Exception as e:
            logger.error(f"Trading cycle error: {e}", exc_info=True)
    
    async def _look_for_entry(self, data: pd.DataFrame):
        """Look for entry opportunities"""
        logger.debug("Analyzing market for entry opportunities...")
        
        try:
            # Ensure data is standardized
            data = self.standardize_dataframe(data)
            if data.empty:
                logger.warning("Data standardization failed")
                return
            
            features = self.feature_engineer.calculate_features(data)
            # Pattern scanner needs raw data, not features
            patterns = self.pattern_scanner.scan_all_patterns(data)
            
            # Filter disabled patterns
            valid_patterns = []
            for pattern in patterns:
                pattern_name = str(pattern.pattern_type).split('.')[-1].lower()
                if pattern_name not in DISABLED_PATTERNS:
                    valid_patterns.append(pattern)
                else:
                    logger.debug(f"Filtered out disabled pattern: {pattern_name}")
            
            # Microstructure analyzer needs raw data, not features
            microstructure = self.microstructure_analyzer.analyze_current_state(data)
            
            # Calculate confidence using the correct method
            result = self.confidence_engine.calculate_confidence(
                data,  # Pass raw data
                valid_patterns  # Pass patterns as discovered_strategies
            )
            confidence = result['confidence']
            trade_decision = result.get('trade_decision')
            action = trade_decision.action if trade_decision else TradeAction.HOLD
            selected_pattern = valid_patterns[0] if valid_patterns else None
            
            self.current_pattern_confidence = confidence
            
            logger.info(f"Confidence: {confidence:.1f}% | Decision: {action}")
            
            if action in [TradeAction.BUY, TradeAction.SELL] and confidence >= self.confidence_engine.min_confidence:
                if not await self.pre_trade_checks():
                    logger.info("Pre-trade checks failed")
                    return
                
                await self._enter_position(action, selected_pattern, confidence, data)
            else:
                logger.info(f"No entry: Confidence {confidence:.1f}% < {self.confidence_engine.min_confidence}%")
                
        except Exception as e:
            logger.error(f"Entry analysis error: {e}", exc_info=True)
    
    async def _manage_position(self, data: pd.DataFrame):
        """Manage open position"""
        if not self.current_position:
            return
        
        # Ensure data is standardized
        data = self.standardize_dataframe(data)
        if data.empty or 'close' not in data.columns:
            logger.warning("Cannot manage position - invalid data")
            return
        
        current_price = data['close'].iloc[-1]
        position = self.current_position
        
        if position.position_type == 1:  # LONG
            pnl = (current_price - position.entry_price) * position.size * 20
        else:  # SHORT
            pnl = (position.entry_price - current_price) * position.size * 20
        
        position.pnl = pnl
        logger.debug(f"Position P&L: ${pnl:.2f} | Current: {current_price:.2f}")
        
        exit_reason = None
        
        # Check stops and targets
        if position.position_type == 1:  # LONG
            if current_price <= position.stop_loss:
                exit_reason = "Stop loss hit"
            elif current_price >= position.take_profit:
                exit_reason = "Take profit hit"
        else:  # SHORT
            if current_price >= position.stop_loss:
                exit_reason = "Stop loss hit"
            elif current_price <= position.take_profit:
                exit_reason = "Take profit hit"
        
        # Check for reversal patterns
        try:
            features = self.feature_engineer.calculate_features(data)
            # Pattern scanner needs raw data, not features
            patterns = self.pattern_scanner.scan_all_patterns(data)
            
            valid_patterns = [p for p in patterns 
                            if str(p.pattern_type).split('.')[-1].lower() not in DISABLED_PATTERNS]
            
            for pattern in valid_patterns:
                if position.position_type == 1 and pattern.direction < 0 and pattern.confidence > 0.4:
                    exit_reason = f"Reversal pattern: {pattern.pattern_type}"
                    break
                elif position.position_type == 2 and pattern.direction > 0 and pattern.confidence > 0.4:
                    exit_reason = f"Reversal pattern: {pattern.pattern_type}"
                    break
                    
        except Exception as e:
            logger.error(f"Pattern check error: {e}")
        
        if exit_reason:
            logger.info(f"Exit signal: {exit_reason}")
            await self.close_position(exit_reason)
        else:
            await self._update_trailing_stop(current_price)
    
    async def _enter_position(self, action: TradeAction, pattern: Optional[PatternType], confidence: float, data: pd.DataFrame):
        """Enter a new position"""
        try:
            current_price = data['close'].iloc[-1]
            
            if action == TradeAction.BUY:
                side = 0  # TopStep BUY
                position_type = 1  # LONG
                stop_loss = current_price - 5
                take_profit = current_price + 10
                side_str = "BUY/LONG"
            else:
                side = 1  # TopStep SELL
                position_type = 2  # SHORT
                stop_loss = current_price + 5
                take_profit = current_price - 10
                side_str = "SELL/SHORT"
            
            size = 1
            
            logger.info(f"ENTERING {side_str}: {size} @ {current_price:.2f}")
            logger.info(f"Pattern: {pattern}, Confidence: {confidence:.1f}%")
            
            response = await topstepx_client.submit_order(
                self.account_id,
                self.contract_id,
                2,
                side,
                size
            )
            
            if response and response.get('success'):
                order_id = response.get('orderId')
                logger.info(f"âœ… Entry order placed: {order_id}")
                
                self.current_position = Position(
                    symbol=self.symbol,
                    side=side,
                    position_type=position_type,
                    size=size,
                    entry_price=current_price,
                    entry_time=datetime.utcnow(),
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    pattern=pattern,
                    confidence=confidence,
                    order_id=order_id
                )
                
                self.current_position_type = position_type
                self.current_position_size = size
                
                self.state = BotState.POSITION_OPEN
                self.trade_count += 1
                
            else:
                logger.error(f"Failed to place entry order: {response}")
                
        except Exception as e:
            logger.error(f"Error entering position: {e}")
    
    async def _update_trailing_stop(self, current_price: float):
        """Update trailing stop"""
        if not self.current_position:
            return
        
        position = self.current_position
        trailing_distance = current_price * self.risk_limits.trailing_stop_percent
        
        if position.position_type == 1:  # LONG
            new_stop = current_price - trailing_distance
            if new_stop > position.stop_loss:
                position.stop_loss = new_stop
                logger.debug(f"Trailing stop updated to {new_stop:.2f}")
        else:  # SHORT
            new_stop = current_price + trailing_distance
            if new_stop < position.stop_loss:
                position.stop_loss = new_stop
                logger.debug(f"Trailing stop updated to {new_stop:.2f}")
    
    def _check_risk_limits(self) -> bool:
        """Check risk limits"""
        if self.daily_pnl <= -self.risk_limits.max_daily_loss:
            logger.error(f"Daily loss limit: ${self.daily_pnl:.2f}")
            return False
        
        if self.current_position and self.current_position.size > self.risk_limits.max_position_size:
            logger.error(f"Position size limit: {self.current_position.size}")
            return False
        
        return True
    
    async def shutdown(self):
        """Shutdown bot gracefully"""
        logger.info("Shutting down bot...")
        self.running = False
        
        if self.current_position:
            logger.warning("Closing position before shutdown...")
            await self.close_position("Bot shutdown")
        
        if topstepx_client.connected:
            await topstepx_client.disconnect()
        
        self.state = BotState.STOPPED
        logger.info("Bot shutdown complete")


async def main():
    """Main entry point"""
    bot = IntelligentTradingBotFixedV2(
        account_id=10983875,
        symbol="NQ.FUT",
        mode="live",
        min_confidence=50
    )
    
    try:
        await bot.initialize()
        await bot.run()
    except Exception as e:
        logger.error(f"Bot failed: {e}")
        await bot.shutdown()


if __name__ == "__main__":
    logger.info("=" * 60)
    logger.info("FIXED V2 NQ Bot - With Data Format Fixes")
    logger.info("=" * 60)
    asyncio.run(main())